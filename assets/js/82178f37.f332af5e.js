"use strict";(self.webpackChunktether_docs_2=self.webpackChunktether_docs_2||[]).push([[839],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=a,d=p["".concat(l,".").concat(m)]||p[m]||u[m]||o;return n?r.createElement(d,i(i({ref:t},h),{},{components:n})):r.createElement(d,i({ref:t},h))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},9694:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},assets:function(){return h},toc:function(){return u},default:function(){return m}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),i=["components"],s={sidebar_position:4},l="Cable Actors",c={unversionedId:"cable-actors",id:"cable-actors",title:"Cable Actors",description:"Tether Cable Actors are self-contained objects in the world that are responsible for handling all of the functionality for a single cable, including settings, physics simulation, mesh generation, and the resultant static mesh.",source:"@site/docs/cable-actors.md",sourceDirName:".",slug:"/cable-actors",permalink:"/TetherDocs/cable-actors",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Cable Placement Mode",permalink:"/TetherDocs/editor-mode"},next:{title:"Example Project",permalink:"/TetherDocs/info/example-project"}},h={},u=[{value:"Physics Simulation",id:"physics-simulation",level:2},{value:"Mesh Generation",id:"mesh-generation",level:2},{value:"Basic Mesh Generation",id:"basic-mesh-generation",level:3},{value:"Custom Mesh Generation",id:"custom-mesh-generation",level:3}],p={toc:u};function m(e){var t=e.components,s=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"cable-actors"},"Cable Actors"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Tether Cable Actors")," are self-contained objects in the world that are responsible for handling all of the functionality for a single cable, including settings, physics simulation, mesh generation, and the resultant static mesh."),(0,o.kt)("p",null,"The overall path of the cable before simulation is determined by a ",(0,o.kt)("strong",{parentName:"p"},"Spline Component")," on the Actor, which may have already been set up using the ",(0,o.kt)("a",{parentName:"p",href:"/TetherDocs/editor-mode"},"Cable Placement Mode")),(0,o.kt)("h2",{id:"physics-simulation"},"Physics Simulation"),(0,o.kt)("p",null,"Tether runs an asynchronous physics simulation for the cable, simulating for a certain amount of time and skipping ahead to the final result so that you don't need to wait for it.\nWhen the cable path or any applicable properties are modified, the simulation is run again automatically so that the cable stays up to date."),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",alt:"Title",src:n(8190).Z,width:"3226",height:"1622"})),(0,o.kt)("h2",{id:"mesh-generation"},"Mesh Generation"),(0,o.kt)("p",null,"Once the physics simulation is complete, Tether generates a mesh for the cable using one of two methods which the user can specify per-cable:"),(0,o.kt)("h3",{id:"basic-mesh-generation"},"Basic Mesh Generation"),(0,o.kt)("p",null,"This mode generates simple geometry for the cable using a specified number of sides and edge loop resolution.\nUnncessary edge loops can be culled automatically based on the angle to optimize the final geometry."),(0,o.kt)("h3",{id:"custom-mesh-generation"},"Custom Mesh Generation"),(0,o.kt)("p",null,"This mode takes a user-specified Static Mesh asset and repeats it along the length of the cable, deforming it similar to how a Spline Mesh would."),(0,o.kt)("p",null,"The number of instances of the mesh to be repeated can be specified by the user, or calculated automatically based on the width and length of the cable and the source mesh.\nMaterial IDs are also copied, allowing the use of the same number of materials as the source mesh."),(0,o.kt)("p",null,"The source mesh must be x axis aligned and have sufficient geometry to allow for proper deformation, just like with spline meshes. When simulating physics with collision with other objects, it's also recommended to keep the mesh as cylindrical as possible as the collision for the cable while it is simulating is approximate and does not factor in the shape of the mesh."),(0,o.kt)("p",null,"As the geometry is copied from the source mesh when the mesh is generated, any changes to the source mesh won't be reflected afterward unless the cable mesh is regenerated."),(0,o.kt)("p",null,"This mode is very powerful for creating more detailed cables, but has the potential to create very dense geometry if not used carefully."),(0,o.kt)("p",null,(0,o.kt)("img",{loading:"lazy",alt:"Title",src:n(306).Z,width:"2108",height:"745"})))}m.isMDXComponent=!0},8190:function(e,t,n){t.Z=n.p+"assets/images/collapsed-3716c31ccd61154fad3290b5a41fd855.png"},306:function(e,t,n){t.Z=n.p+"assets/images/meshtypes-9f10356d1858f328ffa5e24a89d20dcf.png"}}]);